use super::ast::*;
use std::rc::Rc;

grammar;

match {
  r"\s*" => {},
  r"//[^\n\r]*[\n\r]*" => {},
  r"/\*[^*]*\*+([^/*][^*]*\*+)*/" => {},
  _
}

pub CompUnit: CompUnit = {
  <decl: Decl> => vec![<>],
  <comp_unit: CompUnit> <decl: Decl> => {
    comp_unit.into_iter().chain(vec![decl]).collect()
  } 
}

Decl: Decl = {
  <decl: BlockDecl> => <>,
  <ty: TypeSpec> <decl: FuncDeclarator> => Decl::Func(FuncDecl {
    func_type: ty,
    ident: decl.0,
    params: decl.1,
    body: decl.2,
  }),
}

BlockDecl: Decl = {
  "const" <ty: TypeSpec> 
  <list: DeclaratorAndInitializerList> ";" => Decl::Var(DeclaratorAndInitializerList {
    <>,
    is_const: true,
  }),
  <ty: TypeSpec> 
  <list: DeclaratorAndInitializerList> ";" => Decl::Var(DeclaratorAndInitializerList {
    <>,
    is_const: false,
  })
}

FuncDeclarator: (String, ParamList, Option<Block>) = {
  <ident: Ident> "(" ")" <block: FuncBody> => {
    (ident, vec![], block)
  },
  <ident: Ident> "(" <params: ParamList> ")" <block: FuncBody> => {
    (ident, params, block)
  },
}

FuncBody: Option<Block> = {
  ";" => None,
  <block: Block> => Some(<>),
}

TypeSpec: TypeSpec = {
  "void" => TypeSpec::Void,
  "int" => TypeSpec::Int,
}

ParamList: ParamList = {
  <param: Param> => vec![<>],
  <list: ParamList> "," <param: Param> => {
    list.into_iter().chain(vec![param]).collect()
  }
}

Param: Box<Declarator> = {
  "int" <decl: ParamDeclarator> => <>,
}

Block: Block = {
  "{" "}" => vec![],
  "{" <items: BlockItemList> "}" => <>,
}

BlockItemList: Vec<BlockItem> = {
  <item: BlockItem> => vec![item],
  <list: BlockItemList> <item: BlockItem> => {
    list.into_iter().chain(vec![item]).collect()
  }
}

BlockItem: BlockItem = {
  <decl: Decl> => BlockItem::Decl(<>),
  <stmt: Stmt> => BlockItem::Stmt(<>),
}

Stmt: Stmt = {
  <s: PrimaryStmt> => <>,
  <s: IfStmt> => <>,
  <s: IfElseStmt> => <>,
  <s: WhileStmt> => <>,
}

PrimaryStmt: Stmt = {
  <s: Block> => Stmt::Block(<>.into()),
  <s: ExprStmt> => <>,
  <s: ReturnStmt> => <>,
  "break" ";" => Stmt::Break,
  "continue" ";" => Stmt::Continue,
}

/// 关于“悬垂 Else”问题的说明:
///
/// 按 C++ 标准 (https://eel.is/c++draft/stmt.if#1) 说法：
/// - In the second form of if statement (the one including else), 
///   if the first substatement is also an if statement 
///   then that inner if statement shall contain an else part.
///
/// 即：真分支语句如果是 if 语句，则必须以 else 分支结尾。
/// 下文中，带 -NoShortIf 后缀的语句保证不存在单分支的 if。
/// 最后，IfElseStmt 的真分支使用 -NoShortIf 后缀的语句。

StmtNoShortIf: Stmt = {
  <s: PrimaryStmt> => <>,
  <s: IfElseStmtNoShortIf> => <>,
  <s: WhileStmtNoShortIf> => <>,
}

IfStmt: Stmt = {
  "if" "(" <exp: Exp> ")" <stmt: Stmt> => Stmt::If(
    exp,
    stmt.into(),
    None,
  ),
}

IfElseStmt: Stmt = {
  "if" "(" <exp: Exp> ")" <stmt: StmtNoShortIf> "else" <else_stmt: Stmt> => Stmt::If(
    exp, 
    stmt.into(), 
    Some(else_stmt.into())
  ),
}

IfElseStmtNoShortIf: Stmt = {
  "if" "(" <exp: Exp> ")" <stmt: StmtNoShortIf> "else" <else_stmt: StmtNoShortIf> => Stmt::If(
    exp, 
    stmt.into(), 
    Some(else_stmt.into())
  ),
}

WhileStmt: Stmt = {
  "while" "(" <exp: Exp> ")" <stmt: Stmt> => Stmt::While(
    exp,
    stmt.into(),
  ),
}

WhileStmtNoShortIf: Stmt = {
  "while" "(" <exp: Exp> ")" <stmt: StmtNoShortIf> => Stmt::While(
    exp,
    stmt.into(),
  ),
}

ExprStmt: Stmt = {
  ";" => Stmt::Exp(None),
  <exp: Exp> ";" => Stmt::Exp(Some(<>)),
}

ReturnStmt: Stmt = {
  "return" ";" => Stmt::Return(None),
  "return" <exp: Exp> ";" => Stmt::Return(Some(<>)),
}

Exp: Box<Exp> = {
  <exp: AssignExp> => Exp::Assign(<>).into(),
  <lhs: Exp> "," <rhs: AssignExp> => Exp::Comma(<>).into(),
}

AssignExp: Box<AssignExp> = {
  <exp: LOrExp> => AssignExp::LOr(<>).into(),
  <lhs: LOrExp> "=" <rhs: AssignExp> => AssignExp::Assign(<>).into(),
}

LOrExp: Box<LOrExp> = {
  <exp: LAndExp> => LOrExp::And(<>).into(),
  <lhs: LOrExp> "||" <rhs: LAndExp> => LOrExp::Or(<>).into(),
}

LAndExp: Box<LAndExp> = {
  <exp: EqExp> => LAndExp::Eq(<>).into(),
  <lhs: LAndExp> "&&" <rhs: EqExp> => LAndExp::And(<>).into(),
}

EqExp: Box<EqExp> = {
  <exp: RelExp> => EqExp::Rel(<>).into(),
  <lhs: EqExp> <op: EqOp> <rhs: RelExp> => EqExp::Eq(<>).into(),
}

EqOp: EqOp = {
  "==" => EqOp::Equal,
  "!=" => EqOp::NotEqual,
}

RelExp: Box<RelExp> = {
  <exp: AddExp> => RelExp::Add(<>).into(),
  <lhs: RelExp> <op: RelOp> <rhs: AddExp> => RelExp::Rel(<>).into(),
}

RelOp: RelOp = {
  "<" => RelOp::Less,
  "<=" => RelOp::LessEqual,
  ">" => RelOp::Greater,
  ">=" => RelOp::GreaterEqual,
}

AddExp: Box<AddExp> = {
  <exp: MulExp> => AddExp::Mul(<>).into(),
  <lhs: AddExp> <op: AddOp> <rhs: MulExp> => AddExp::Add(<>).into(),
}

AddOp: AddOp = {
  "+" => AddOp::Plus,
  "-" => AddOp::Minus,
}

MulExp: Box<MulExp> = {
  <exp: UnaryExp> => MulExp::Unary(<>).into(),
  <lhs: MulExp> <op: MulOp> <rhs: UnaryExp> => MulExp::Mul(<>).into(),
}

MulOp: MulOp = {
  "*" => MulOp::Multiply,
  "/" => MulOp::Divide,
  "%" => MulOp::Modulo,
}

UnaryExp: Box<UnaryExp> = {
  <exp: PostfixExp> => UnaryExp::Postfix(<>).into(),
  "*" <exp: UnaryExp> => UnaryExp::Deref(<>).into(),
  "&" <exp: UnaryExp> => UnaryExp::Address(<>).into(),
  <op: UnaryOp> <exp: UnaryExp> => UnaryExp::Op(op, exp.into()).into(),
}

PostfixExp: Box<PostfixExp> = {
  <exp: PrimaryExp> => PostfixExp::Primary(<>).into(),
  <lhs: PostfixExp> "[" <rhs: Exp> "]" => PostfixExp::Subscript(<>).into(),
  <func: Ident> "(" ")" => PostfixExp::Call(func, vec![]).into(),
  <func: Ident> "(" <args: ArgList> ")" => PostfixExp::Call(func, args).into(),
}

ArgList: Vec<Box<AssignExp>> = {
  <exp: AssignExp> => vec![exp],
  <args: ArgList> "," <exp: AssignExp> => {
    args.into_iter().chain(vec![exp]).collect()
  },
}

UnaryOp: UnaryOp = {
  "+" => UnaryOp::Positive,
  "-" => UnaryOp::Negative,
  "!" => UnaryOp::Not,
}

PrimaryExp: PrimaryExp = {
  "(" <exp: Exp> ")" => PrimaryExp::Paren(<>.into()),
  <num: Number> => PrimaryExp::Num(<>),
  <ident: Ident> => PrimaryExp::Ident(<>),
}

Number: i32 = <num: IntConst> => <>;

Ident: String = r"[_a-zA-Z][_a-zA-Z0-9]*" => <>.into();

IntConst: i32 = {
  r"[1-9][0-9]*" => i32::from_str_radix(<>, 10).unwrap(),
  r"0[0-7]*" => i32::from_str_radix(<>, 8).unwrap(),
  r"0[xX][0-9a-fA-F]+" => i32::from_str_radix(&<>[2..], 16).unwrap(),
  r"'[ -~]'" => <>.bytes().nth(1).unwrap() as i32,
  r"'\\n'" => '\n' as i32,
}

DeclaratorAndInitializerList: Vec<DeclaratorAndInitializer> = {
  <def: DeclaratorAndInitializer> => vec![<>],
  <defs: DeclaratorAndInitializerList> "," <def: DeclaratorAndInitializer> => {
    defs.into_iter().chain(vec![def]).collect()
  },
}

DeclaratorAndInitializer: DeclaratorAndInitializer = {
  <decl: Declarator> => (decl, None),
  <decl: Declarator> "=" <init: Initializer> => (decl, Some(init)),
}

Initializer: Initializer = {
  <exp: AssignExp> => Initializer::Simple(<>),
  "{" "}" => Initializer::Aggregate(vec![]),
  "{" <list: InitializerList> "}" => Initializer::Aggregate(<>),
}

InitializerList: Vec<Rc<Initializer>> = {
  <init: Initializer> => vec![init.into()],
  <list: InitializerList> "," <init: Initializer> => {
    list.into_iter().chain(vec![init.into()]).collect()
  },
}

Declarator: Box<Declarator> = {
  <ident: Ident> => Declarator::Ident(<>).into(),
  "*" <decl: Declarator> => Declarator::Pointer(<>).into(),
  <decl: NoPtrDeclarator> "[" <exp: Exp> "]" => Declarator::Array(<>).into(),
}

NoPtrDeclarator: Box<Declarator> = {
  <ident: Ident> => Declarator::Ident(<>).into(),
  "(" "*" <decl: Declarator> ")" => Declarator::Pointer(<>).into(),
  <decl: NoPtrDeclarator> "[" <exp: Exp> "]" => Declarator::Array(<>).into(),
}

ParamDeclarator: Box<Declarator> = {
  <ident: Ident> => Declarator::Ident(<>).into(),
  "*" <decl: ParamDeclarator> => Declarator::Pointer(<>).into(),
  <decl: ParamDeclaratorArraySpec> => <>,
}

NoPtrParamDeclarator: Box<Declarator> = {
  <ident: Ident> => Declarator::Ident(<>).into(),
  "(" "*" <decl: ParamDeclarator> ")" => Declarator::Pointer(<>).into(),
  <decl: ParamDeclaratorArraySpec> => <>,
}

ParamDeclaratorArraySpec: Box<Declarator> = {
  <decl: NoPtrParamDeclarator> "[" <exp: Exp> "]" => Declarator::Array(<>).into(),
  <decl: NoPtrParamDeclarator> "[" "]" => Declarator::Pointer(<>).into(),
}
